"""
Report Generator
Creates police-ready reports in JSON, PDF, and CSV formats.
Includes all extracted intelligence, transcript, URL scan results, and timeline.
"""

import csv
import io
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from features.live_takeover.session_manager import (
    LiveSessionState,
    live_session_manager,
)

logger = logging.getLogger("live_takeover.report")


class ReportGenerator:
    """
    Generates comprehensive reports from live takeover sessions.
    Formats: JSON (machine), PDF (police-ready), CSV (cybercrime portals).
    """
    
    REPORT_DIR = Path("storage/reports")
    
    def __init__(self):
        self.REPORT_DIR.mkdir(parents=True, exist_ok=True)
    
    async def generate_report(
        self,
        session_id: str,
        format: str = "json",
        include_audio_refs: bool = True
    ) -> Dict[str, Any]:
        """
        Generate a full report for a live session.
        
        Args:
            session_id: Live session ID
            format: "json", "pdf", or "csv"
            include_audio_refs: Include links to stored audio files
            
        Returns:
            {
                "report_id": str,
                "format": str,
                "file_path": str | None,
                "data": dict (for JSON)
            }
        """
        session = await live_session_manager.get_session(session_id)
        if not session:
            raise ValueError(f"Session {session_id} not found")
        
        report_data = self._build_report_data(session, include_audio_refs)
        report_id = f"report-{session_id}-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
        
        if format == "json":
            return self._generate_json(report_id, report_data)
        elif format == "pdf":
            return await self._generate_pdf(report_id, report_data)
        elif format == "csv":
            return self._generate_csv(report_id, report_data)
        else:
            raise ValueError(f"Unsupported format: {format}")
    
    def _build_report_data(
        self,
        session: LiveSessionState,
        include_audio_refs: bool
    ) -> Dict[str, Any]:
        """Build structured report data from session."""
        
        # ── Header ────────────────────────────────────────────
        report = {
            "report_header": {
                "title": "Scam Engagement Intelligence Report",
                "generated_at": datetime.utcnow().isoformat(),
                "session_id": session.session_id,
                "original_session_id": session.original_session_id,
                "classification": "CONFIDENTIAL — FOR LAW ENFORCEMENT USE",
                "disclaimer": (
                    "This report was generated by an AI-assisted honeypot system. "
                    "All engagement was conducted to extract intelligence from a suspected scammer. "
                    "No real personal/financial data was shared."
                )
            },
            
            # ── Session Overview ──────────────────────────────
            "session_overview": {
                "started_at": session.started_at.isoformat(),
                "ended_at": session.ended_at.isoformat() if session.ended_at else None,
                "duration_seconds": (
                    (session.ended_at or datetime.utcnow()) - session.started_at
                ).total_seconds(),
                "status": session.status.value,
                "mode_switches": len(session.mode_history),
                "mode_history": [
                    {"from": m.get("from"), "to": m.get("to"), "switched_at": m.get("at"), "turn": m.get("turn")}
                    for m in session.mode_history
                ],
                "final_mode": session.current_mode.value,
                "turn_count": session.turn_count,
                "threat_level": session.threat_level
            },
            
            # ── Scammer Profile ───────────────────────────────
            "scammer_profile": self._build_scammer_profile(session),
            
            # ── Extracted Intelligence ────────────────────────
            "intelligence": self._build_intelligence_section(session),
            
            # ── URL Analysis ──────────────────────────────────
            "url_analysis": self._build_url_section(session),
            
            # ── Conversation Transcript ───────────────────────
            "transcript": self._build_transcript(session),
            
            # ── Tactical Analysis ─────────────────────────────
            "tactical_analysis": {
                "detected_tactics": session.detected_tactics,
                "tactic_count": len(session.detected_tactics),
                "threat_escalation": session.threat_level > 0.7
            }
        }
        
        if include_audio_refs:
            report["audio_references"] = {
                "note": "Audio files are stored locally and referenced by path",
                "chunk_count": len(session.audio_buffer)
            }
        
        return report
    
    def _build_scammer_profile(self, session: LiveSessionState) -> Dict[str, Any]:
        """Build scammer profile from extracted entities."""
        profile = {
            "phone_numbers": [],
            "names": [],
            "organizations": [],
            "claimed_titles": []
        }
        
        for entity in session.extracted_entities:
            if entity.entity_type == "phone":
                profile["phone_numbers"].append(entity.value)
            elif entity.entity_type == "name":
                profile["names"].append(entity.value)
            elif entity.entity_type == "organization":
                profile["organizations"].append(entity.value)
        
        # Deduplicate
        for key in profile:
            profile[key] = list(set(profile[key]))
        
        return profile
    
    def _build_intelligence_section(self, session: LiveSessionState) -> Dict[str, Any]:
        """Build detailed intelligence section."""
        entities_by_type: Dict[str, list] = {}
        
        for entity in session.extracted_entities:
            et = entity.entity_type
            if et not in entities_by_type:
                entities_by_type[et] = []
            entities_by_type[et].append({
                "value": entity.value,
                "confidence": entity.confidence,
                "context": entity.context,
                "extracted_at": entity.extracted_at.isoformat()
            })
        
        return {
            "total_entities": len(session.extracted_entities),
            "entity_types": list(entities_by_type.keys()),
            "entities": entities_by_type,
            "high_value_entities": [
                {
                    "type": e.entity_type,
                    "value": e.value,
                    "confidence": e.confidence
                }
                for e in session.extracted_entities
                if e.entity_type in ("bank_account", "upi_id", "aadhaar", "pan", "ifsc")
            ]
        }
    
    def _build_url_section(self, session: LiveSessionState) -> Dict[str, Any]:
        """Build URL analysis section."""
        return {
            "urls_scanned": len(session.url_scan_results),
            "malicious_urls": sum(
                1 for r in session.url_scan_results if not r.is_safe
            ),
            "results": [
                {
                    "url": r.url,
                    "is_safe": r.is_safe,
                    "risk_score": r.risk_score,
                    "findings": r.findings,
                    "scanned_at": r.scanned_at.isoformat()
                }
                for r in session.url_scan_results
            ]
        }
    
    def _build_transcript(self, session: LiveSessionState) -> List[Dict[str, str]]:
        """Build conversation transcript."""
        transcript = []
        
        for entry in session.transcript:
            transcript.append({
                "speaker": entry.get("speaker", "unknown"),
                "text": entry.get("text", ""),
                "timestamp": entry.get("timestamp", ""),
            })
        
        return transcript
    
    # ── JSON Output ───────────────────────────────────────────
    
    def _generate_json(
        self,
        report_id: str,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate JSON report."""
        file_path = self.REPORT_DIR / f"{report_id}.json"
        
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, default=str, ensure_ascii=False)
        
        logger.info(f"JSON report generated: {file_path}")
        
        # Upload to Cloudinary
        cloudinary_url = self._upload_to_cloudinary(file_path)
        
        return {
            "report_id": report_id,
            "format": "json",
            "file_path": str(file_path),
            "cloudinary_url": cloudinary_url,
            "data": data
        }
    
    # ── PDF Output ────────────────────────────────────────────
    
    async def _generate_pdf(
        self,
        report_id: str,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate PDF report using reportlab."""
        try:
            from reportlab.lib import colors
            from reportlab.lib.enums import TA_CENTER, TA_LEFT
            from reportlab.lib.pagesizes import A4
            from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet
            from reportlab.lib.units import cm, mm
            from reportlab.platypus import (
                Paragraph,
                SimpleDocTemplate,
                Spacer,
                Table,
                TableStyle,
            )
        except ImportError:
            logger.warning("reportlab not installed, falling back to JSON")
            return self._generate_json(report_id, data)
        
        file_path = self.REPORT_DIR / f"{report_id}.pdf"
        
        doc = SimpleDocTemplate(
            str(file_path),
            pagesize=A4,
            topMargin=2 * cm,
            bottomMargin=2 * cm
        )
        
        styles = getSampleStyleSheet()
        title_style = ParagraphStyle(
            "ReportTitle",
            parent=styles["Title"],
            fontSize=18,
            alignment=TA_CENTER,
            spaceAfter=12
        )
        heading_style = ParagraphStyle(
            "SectionHeading",
            parent=styles["Heading2"],
            fontSize=14,
            textColor=colors.HexColor("#1a1a2e"),
            spaceAfter=8
        )
        body_style = ParagraphStyle(
            "ReportBody",
            parent=styles["Normal"],
            fontSize=10,
            spaceAfter=4
        )
        
        elements = []
        header = data.get("report_header", {})
        overview = data.get("session_overview", {})
        intel = data.get("intelligence", {})
        urls = data.get("url_analysis", {})
        
        # ── Title ─────────────────────────────────────────
        elements.append(Paragraph(header.get("title", "Report"), title_style))
        elements.append(Paragraph(
            f"Generated: {header.get('generated_at', '')}",
            body_style
        ))
        elements.append(Paragraph(
            header.get("classification", ""),
            ParagraphStyle("Classification", parent=body_style, textColor=colors.red, fontSize=11)
        ))
        elements.append(Spacer(1, 12))
        
        # ── Disclaimer ────────────────────────────────────
        elements.append(Paragraph(header.get("disclaimer", ""), body_style))
        elements.append(Spacer(1, 20))
        
        # ── Session Overview ──────────────────────────────
        elements.append(Paragraph("Session Overview", heading_style))
        overview_data = [
            ["Session ID", overview.get("started_at", "")[:19]],
            ["Duration", f"{overview.get('duration_seconds', 0):.0f} seconds"],
            ["Turns", str(overview.get("turn_count", 0))],
            ["Threat Level", f"{overview.get('threat_level', 0):.1%}"],
            ["Mode Switches", str(overview.get("mode_switches", 0))],
        ]
        t = Table(overview_data, colWidths=[5 * cm, 10 * cm])
        t.setStyle(TableStyle([
            ("BACKGROUND", (0, 0), (0, -1), colors.HexColor("#e8e8e8")),
            ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
            ("FONTSIZE", (0, 0), (-1, -1), 10),
            ("PADDING", (0, 0), (-1, -1), 6),
        ]))
        elements.append(t)
        elements.append(Spacer(1, 16))
        
        # ── Intelligence Summary ──────────────────────────
        elements.append(Paragraph("Extracted Intelligence", heading_style))
        elements.append(Paragraph(
            f"Total entities extracted: {intel.get('total_entities', 0)}",
            body_style
        ))
        
        high_value = intel.get("high_value_entities", [])
        if high_value:
            elements.append(Paragraph("High-Value Entities:", body_style))
            hv_data = [["Type", "Value", "Confidence"]]
            for e in high_value:
                hv_data.append([e["type"], e["value"], f"{e['confidence']:.0%}"])
            t = Table(hv_data, colWidths=[4 * cm, 8 * cm, 3 * cm])
            t.setStyle(TableStyle([
                ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#1a1a2e")),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
                ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
                ("FONTSIZE", (0, 0), (-1, -1), 9),
                ("PADDING", (0, 0), (-1, -1), 4),
            ]))
            elements.append(t)
        
        elements.append(Spacer(1, 16))
        
        # ── URL Analysis ──────────────────────────────────
        url_results = urls.get("results", [])
        if url_results:
            elements.append(Paragraph("URL Analysis", heading_style))
            url_data = [["URL", "Safe?", "Risk"]]
            for r in url_results:
                url_display = r["url"][:50] + ("..." if len(r["url"]) > 50 else "")
                url_data.append([
                    url_display,
                    "Yes" if r["is_safe"] else "NO",
                    f"{r['risk_score']:.0%}"
                ])
            t = Table(url_data, colWidths=[9 * cm, 3 * cm, 3 * cm])
            t.setStyle(TableStyle([
                ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#1a1a2e")),
                ("TEXTCOLOR", (0, 0), (-1, 0), colors.white),
                ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
                ("FONTSIZE", (0, 0), (-1, -1), 9),
                ("PADDING", (0, 0), (-1, -1), 4),
            ]))
            elements.append(t)
            elements.append(Spacer(1, 16))
        
        # ── Tactical Analysis ─────────────────────────────
        tactics = data.get("tactical_analysis", {})
        detected = tactics.get("detected_tactics", [])
        if detected:
            elements.append(Paragraph("Detected Scam Tactics", heading_style))
            for tactic in detected:
                elements.append(Paragraph(f"• {tactic.replace('_', ' ').title()}", body_style))
            elements.append(Spacer(1, 16))
        
        # ── Transcript ────────────────────────────────────
        transcript = data.get("transcript", [])
        if transcript:
            elements.append(Paragraph("Conversation Transcript", heading_style))
            for entry in transcript[:100]:  # Limit to 100 entries for PDF
                speaker = entry.get("speaker", "?").upper()
                text = entry.get("text", "")[:200]
                ts = entry.get("timestamp", "")[:19]
                elements.append(Paragraph(
                    f"<b>[{ts}] {speaker}:</b> {text}",
                    body_style
                ))
            
            if len(transcript) > 100:
                elements.append(Paragraph(
                    f"... and {len(transcript) - 100} more entries (see full JSON report)",
                    body_style
                ))
        
        # ── Build PDF ─────────────────────────────────────
        doc.build(elements)
        
        logger.info(f"PDF report generated: {file_path}")
        
        # Upload to Cloudinary
        cloudinary_url = self._upload_to_cloudinary(file_path)
        
        return {
            "report_id": report_id,
            "format": "pdf",
            "file_path": str(file_path),
            "cloudinary_url": cloudinary_url,
            "data": None  # PDF is file-only
        }
    
    # ── CSV Output (Cybercrime Portal Format) ─────────────────
    
    def _generate_csv(
        self,
        report_id: str,
        data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Generate CSV for cybercrime portal submission.
        Follows Indian Cybercrime Portal format where applicable.
        """
        file_path = self.REPORT_DIR / f"{report_id}.csv"
        
        rows = []
        header = data.get("report_header", {})
        overview = data.get("session_overview", {})
        intel = data.get("intelligence", {})
        profile = data.get("scammer_profile", {})
        
        # ── Incident Details ──────────────────────────────
        rows.append(["INCIDENT REPORT"])
        rows.append(["Report ID", report_id])
        rows.append(["Generated At", header.get("generated_at", "")])
        rows.append(["Session Started", overview.get("started_at", "")])
        rows.append(["Duration (s)", str(overview.get("duration_seconds", 0))])
        rows.append(["Threat Level", f"{overview.get('threat_level', 0):.1%}"])
        rows.append([])
        
        # ── Scammer Details ───────────────────────────────
        rows.append(["SCAMMER DETAILS"])
        for phone in profile.get("phone_numbers", []):
            rows.append(["Phone Number", phone])
        for name in profile.get("names", []):
            rows.append(["Claimed Name", name])
        for org in profile.get("organizations", []):
            rows.append(["Claimed Organization", org])
        rows.append([])
        
        # ── Financial Intelligence ────────────────────────
        rows.append(["FINANCIAL INTELLIGENCE"])
        entities = intel.get("entities", {})
        for acct in entities.get("bank_account", []):
            rows.append(["Bank Account", acct["value"], f"Confidence: {acct['confidence']:.0%}"])
        for upi in entities.get("upi_id", []):
            rows.append(["UPI ID", upi["value"], f"Confidence: {upi['confidence']:.0%}"])
        for ifsc in entities.get("ifsc", []):
            rows.append(["IFSC Code", ifsc["value"], f"Confidence: {ifsc['confidence']:.0%}"])
        rows.append([])
        
        # ── Identity Intelligence ─────────────────────────
        rows.append(["IDENTITY MARKERS"])
        for aadhaar in entities.get("aadhaar", []):
            rows.append(["Aadhaar Number", aadhaar["value"]])
        for pan in entities.get("pan", []):
            rows.append(["PAN Number", pan["value"]])
        for email in entities.get("email", []):
            rows.append(["Email", email["value"]])
        rows.append([])
        
        # ── URLs ──────────────────────────────────────────
        url_results = data.get("url_analysis", {}).get("results", [])
        if url_results:
            rows.append(["MALICIOUS URLS"])
            rows.append(["URL", "Safe", "Risk Score", "Findings"])
            for r in url_results:
                rows.append([
                    r["url"],
                    "Yes" if r["is_safe"] else "No",
                    f"{r['risk_score']:.0%}",
                    "; ".join(r.get("findings", [])[:3])
                ])
            rows.append([])
        
        # ── Tactics ───────────────────────────────────────
        tactics = data.get("tactical_analysis", {}).get("detected_tactics", [])
        if tactics:
            rows.append(["SCAM TACTICS DETECTED"])
            for tactic in tactics:
                rows.append([tactic])
            rows.append([])
        
        # ── Write CSV ─────────────────────────────────────
        with open(file_path, "w", newline="", encoding="utf-8") as f:
            writer = csv.writer(f)
            writer.writerows(rows)
        
        logger.info(f"CSV report generated: {file_path}")
        
        # Upload to Cloudinary
        cloudinary_url = self._upload_to_cloudinary(file_path)
        
        return {
            "report_id": report_id,
            "format": "csv",
            "file_path": str(file_path),
            "cloudinary_url": cloudinary_url,
            "data": None
        }
    
    def _upload_to_cloudinary(self, file_path: Path) -> Optional[str]:
        """Upload a report file to Cloudinary and return the secure URL."""
        try:
            from services.cloudinary_service import cloudinary_service
            with open(file_path, "rb") as f:
                data = f.read()
            return cloudinary_service.upload_report(data, file_path.name)
        except Exception as e:
            logger.error(f"Report Cloudinary upload failed: {e}")
            return None
    
    async def generate_all_formats(self, session_id: str) -> Dict[str, Any]:
        """Generate report in all formats at once."""
        results = {}
        for fmt in ("json", "pdf", "csv"):
            try:
                results[fmt] = await self.generate_report(session_id, format=fmt)
            except Exception as e:
                logger.error(f"Report generation failed ({fmt}): {e}")
                results[fmt] = {"error": str(e)}
        return results


# Module-level singleton
report_generator = ReportGenerator()
